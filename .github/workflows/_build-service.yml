name: Build Service

on:
  workflow_call:
    inputs:
      service:
        required: true
        type: string
        description: 'Service name'
      service-path:
        required: true
        type: string
        description: 'Path to service (e.g., apps/dashboard, services/api)'
      build-type:
        required: false
        type: string
        default: 'docker'
        description: 'Build type: docker, npm, yarn, hugo, zip, none'
      build-output:
        required: false
        type: string
        default: ''
        description: 'Build output directory (for npm, yarn, hugo builds)'
      build-context:
        required: false
        type: string
        default: ''
        description: 'Docker build context (default: service-path, use "." for repo root when using shared packages)'
      version-suffix:
        required: false
        type: string
        default: ''
        description: 'Version suffix (beta.N, rc.N, or empty for production)'
      registry:
        required: false
        type: string
        default: 'ghcr.io'
        description: 'Container registry'
      push:
        required: false
        type: boolean
        default: true
        description: 'Push image to registry (Docker only)'
      skip-build:
        required: false
        type: boolean
        default: false
        description: 'Skip build (only calculate version for deploy-only changes)'
    outputs:
      version:
        description: 'Full version string (new version if built, or last existing version if skipped)'
        value: ${{ jobs.build.outputs.version }}
      image:
        description: 'Full image name with tag (Docker only)'
        value: ${{ jobs.build-docker.outputs.image }}
      digest:
        description: 'Image digest (Docker only)'
        value: ${{ jobs.build-docker.outputs.digest }}
      artifact-name:
        description: 'Build artifact name (non-Docker builds)'
        value: ${{ jobs.build.outputs.artifact-name }}
      keep-existing-image:
        description: 'True if deploy should use the currently running image (k8s-only changes)'
        value: ${{ jobs.build.outputs.keep-existing-image }}

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      artifact-name: ${{ steps.artifact.outputs.name }}
      skip-docker: ${{ steps.check-type.outputs.skip-docker }}
      keep-existing-image: ${{ inputs.skip-build }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check build type
        id: check-type
        run: |
          BUILD_TYPE="${{ inputs.build-type }}"
          echo "build_type=$BUILD_TYPE" >> $GITHUB_OUTPUT

          if [[ "$BUILD_TYPE" == "docker" ]]; then
            echo "skip-docker=false" >> $GITHUB_OUTPUT
          else
            echo "skip-docker=true" >> $GITHUB_OUTPUT
          fi

          echo "### Build Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- Service: ${{ inputs.service }}" >> $GITHUB_STEP_SUMMARY
          echo "- Build type: $BUILD_TYPE" >> $GITHUB_STEP_SUMMARY

      - name: Determine version
        id: version
        run: |
          SERVICE_PATH="${{ inputs.service-path }}"

          # Read base version from VERSION file or package.json
          if [[ -f "${SERVICE_PATH}/VERSION" ]]; then
            BASE_VERSION=$(cat "${SERVICE_PATH}/VERSION" | tr -d '[:space:]')
          elif [[ -f "${SERVICE_PATH}/package.json" ]]; then
            BASE_VERSION=$(jq -r '.version' "${SERVICE_PATH}/package.json")
          else
            BASE_VERSION="1.0.0"
          fi

          # Apply version suffix if provided
          if [[ -n "${{ inputs.version-suffix }}" ]]; then
            FULL_VERSION="${BASE_VERSION}-${{ inputs.version-suffix }}"
          else
            FULL_VERSION="${BASE_VERSION}"
          fi

          echo "base_version=${BASE_VERSION}" >> $GITHUB_OUTPUT
          echo "version=${FULL_VERSION}" >> $GITHUB_OUTPUT

          echo "- Base version: ${BASE_VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "- Full version: ${FULL_VERSION}" >> $GITHUB_STEP_SUMMARY

      # === Skip build (deploy-only changes) ===
      - name: Skip build (deploy-only)
        if: inputs.skip-build
        run: |
          echo "Skipping build - only k8s/deploy changes detected" >> $GITHUB_STEP_SUMMARY
          echo "Deploy will use the currently running image" >> $GITHUB_STEP_SUMMARY

      # === None: No build needed ===
      - name: Skip build (none)
        if: inputs.build-type == 'none' && !inputs.skip-build
        run: |
          echo "No build needed for this service" >> $GITHUB_STEP_SUMMARY

      # === NPM Build ===
      - name: Setup Node.js
        if: (inputs.build-type == 'npm' || inputs.build-type == 'yarn') && !inputs.skip-build
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: NPM Build
        if: inputs.build-type == 'npm' && !inputs.skip-build
        working-directory: ${{ inputs.service-path }}
        run: |
          npm ci
          npm run build
          echo "NPM build completed" >> $GITHUB_STEP_SUMMARY

      # === Yarn Build ===
      - name: Yarn Build
        if: inputs.build-type == 'yarn' && !inputs.skip-build
        working-directory: ${{ inputs.service-path }}
        run: |
          yarn install --frozen-lockfile
          yarn build
          echo "Yarn build completed" >> $GITHUB_STEP_SUMMARY

      # === Hugo Build ===
      - name: Setup Hugo
        if: inputs.build-type == 'hugo' && !inputs.skip-build
        uses: peaceiris/actions-hugo@v3
        with:
          hugo-version: 'latest'
          extended: true

      - name: Hugo Build
        if: inputs.build-type == 'hugo' && !inputs.skip-build
        working-directory: ${{ inputs.service-path }}
        run: |
          hugo --minify
          echo "Hugo build completed" >> $GITHUB_STEP_SUMMARY

      # === Zip Build ===
      - name: Create zip archive
        if: inputs.build-type == 'zip' && !inputs.skip-build
        run: |
          cd ${{ inputs.service-path }}
          zip -r ../build-${{ inputs.service }}-${{ steps.version.outputs.version }}.zip .
          echo "Zip archive created" >> $GITHUB_STEP_SUMMARY

      # === Upload artifact for non-Docker builds ===
      - name: Determine artifact path
        id: artifact
        if: inputs.build-type != 'docker' && inputs.build-type != 'none' && !inputs.skip-build
        run: |
          SERVICE_PATH="${{ inputs.service-path }}"
          BUILD_TYPE="${{ inputs.build-type }}"
          BUILD_OUTPUT="${{ inputs.build-output }}"

          # Determine output directory
          if [[ -n "$BUILD_OUTPUT" ]]; then
            OUTPUT_DIR="${SERVICE_PATH}/${BUILD_OUTPUT}"
          elif [[ "$BUILD_TYPE" == "npm" ]] || [[ "$BUILD_TYPE" == "yarn" ]]; then
            OUTPUT_DIR="${SERVICE_PATH}/dist"
          elif [[ "$BUILD_TYPE" == "hugo" ]]; then
            OUTPUT_DIR="${SERVICE_PATH}/public"
          elif [[ "$BUILD_TYPE" == "zip" ]]; then
            OUTPUT_DIR="build-${{ inputs.service }}-${{ steps.version.outputs.version }}.zip"
          else
            OUTPUT_DIR="${SERVICE_PATH}"
          fi

          ARTIFACT_NAME="build-${{ inputs.service }}-${{ steps.version.outputs.version }}"
          echo "path=$OUTPUT_DIR" >> $GITHUB_OUTPUT
          echo "name=$ARTIFACT_NAME" >> $GITHUB_OUTPUT

      - name: Upload build artifact
        if: inputs.build-type != 'docker' && inputs.build-type != 'none' && !inputs.skip-build
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.artifact.outputs.name }}
          path: ${{ steps.artifact.outputs.path }}
          retention-days: 7

  # Docker build runs as separate job to allow conditional execution
  build-docker:
    needs: build
    if: inputs.build-type == 'docker' && !inputs.skip-build
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.meta.outputs.tags }}
      digest: ${{ steps.build-push.outputs.digest }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        if: inputs.push
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine image path
        id: image-path
        run: |
          # Extract service type from path (e.g., services/emailer -> services)
          SERVICE_TYPE=$(echo "${{ inputs.service-path }}" | cut -d'/' -f1)
          echo "type=$SERVICE_TYPE" >> $GITHUB_OUTPUT

          # Container registries require lowercase names
          OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          echo "owner=$OWNER" >> $GITHUB_OUTPUT

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ inputs.registry }}/${{ steps.image-path.outputs.owner }}/${{ steps.image-path.outputs.type }}/${{ inputs.service }}
          tags: |
            type=raw,value=${{ needs.build.outputs.version }}
            type=raw,value=latest,enable=${{ inputs.version-suffix == '' }}
            type=sha,prefix=

      - name: Build and push
        id: build-push
        uses: docker/build-push-action@v5
        with:
          context: ${{ inputs.build-context != '' && inputs.build-context || inputs.service-path }}
          file: ${{ inputs.service-path }}/Dockerfile
          push: ${{ inputs.push }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ needs.build.outputs.version }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}

      - name: Create git tag
        if: inputs.push
        run: |
          TAG="${{ inputs.service }}/v${{ needs.build.outputs.version }}"

          # Check if tag already exists
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists, skipping"
          else
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git tag -a "$TAG" -m "Release ${{ inputs.service }} v${{ needs.build.outputs.version }}"
            git push origin "$TAG"
            echo "Created tag: $TAG" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Output summary
        run: |
          echo "### Docker Build Complete" >> $GITHUB_STEP_SUMMARY
          echo "- Image: ${{ steps.meta.outputs.tags }}" >> $GITHUB_STEP_SUMMARY
          echo "- Digest: ${{ steps.build-push.outputs.digest }}" >> $GITHUB_STEP_SUMMARY
